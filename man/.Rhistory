corPerP(df[[pos_1]]
, df[[pos_2]]
, p.value = p.value
, use = "pairwise.complete.obs")
lmP=function(y,x,p.value){
sum.res<-summary(
stats::lm(y ~ as.factor(x))
)
pv<- stats::pf (sum.res$fstatistic[1],sum.res$fstatistic[2],
sum.res$fstatistic[3],,lower.tail=F)
if(pv<p.value) {
r<-sqrt(sum.res[["r.squared"]])
cat(paste("alternative hypothesis: true correlation is not equal to 0","\n",
"p-value: ",pv))
} else {
r<-0
cat(paste("there is no correlation at the confidence level  p-value<",p.value,"\n",
"p-value: ",pv))
}
return(r)
}
cramersVP=function(y,x,p.value,simulate.p.value = TRUE){
pv<-chisq.test(y,x,simulate.p.value=simulate.p.value)$p.value
if(pv<p.value) {
r<-lsr::cramersV(y,x, simulate.p.value=simulate.p.value)
cat(paste("alternative hypothesis: true correlation is not equal to 0","\n",
"p-value: ",pv))
} else {
r<-0
cat(paste("there is no correlation at the confidence level  p-value<",p.value,"\n",
"p-value: ",pv))
}
return(r)
}
corPerP=function(y,x,p.value,use){
res<- stats::cor.test(y,x,use,method="pearson",alternative = "two.sided")
pv<-res[["p.value"]]
if(pv<p.value) {
r<-res[["estimate"]]
cat(paste("alternative hypothesis: true correlation is not equal to 0","\n",
"p-value: ",pv))
} else {
r<-0
cat(paste("there is no correlation at the confidence level  p-value<",p.value,"\n",
"p-value: ",pv))
}
return(r)
}
##############################################################################
cor_fun <- function(df,pos_1, pos_2,p.value){
# both are numeric
if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
class(df[[pos_2]]) %in% c("integer", "numeric")){
r <- try(corPerP(df[[pos_1]]
, df[[pos_2]]
, p.value = p.value
, use = "pairwise.complete.obs")
)
}
# one is numeric and other is a factor/character
if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
class(df[[pos_2]]) %in% c("factor", "character")){
r <- try(
lmP(df[[pos_1]],df[[pos_2]],p.value = p.value)
)
}
if(class(df[[pos_2]]) %in% c("integer", "numeric") &&
class(df[[pos_1]]) %in% c("factor", "character")){
r <- try(
lmP(df[[pos_2]],df[[pos_1]],p.value = p.value)
)
}
# both are factor/character
if(class(df[[pos_1]]) %in% c("factor", "character") &&
class(df[[pos_2]]) %in% c("factor", "character")){
r <- try(cramersVP(df[[pos_1]], df[[pos_2]],p.value = p.value,
simulate.p.value = TRUE))
}
if((class(r) %in% "try-error")){
warnings(cat("some operations produces Nas values it will be replaced by 0.","\n",
pos_1, " FUN " ,pos_2,"\n"))
r<-0
}
return(r)
}
cor_fun <- Vectorize(cor_fun, vectorize.args=c("pos_1", "pos_2"))
#parallel corr matrix
cor_par <- function (df) {
`%dopar%` <- foreach::`%dopar%`
`%:%` <- foreach::`%:%`
dim<-NCOL(df)
corp <- foreach::foreach(i=1:dim,.export='cor_fun') %:%
foreach::foreach (j=1:dim) %dopar% {
corp = cor_fun(df,i,j,p.value=p.value)
}
matrix(unlist(corp), ncol=ncol(df))
}
# parallel corr matrix
if(isTRUE(parallel)){
doParallel::registerDoParallel(min(parallel::detectCores(),n.cores))
corrmat<-cor_par(df)
env <- foreach:::.foreachGlobals
rm(list=ls(name=env), pos=env)
} else {
# sequential corr matrix
corrmat <- outer(1:NCOL(df)
, 1:NCOL(df)
, function(x, y){cor_fun(df=df,x,y,p.value=p.value)})
}
rownames(corrmat) <- colnames(df)
colnames(corrmat) <- colnames(df)
return(corrmat)
}
corrP = function(df,parallel=TRUE,n.cores=1,p.value=0.5,verbose=TRUE){
stopifnot(inherits(df, "data.frame"))
stopifnot(sapply(df, class) %in% c("integer"
, "numeric"
, "factor"
, "character"))
##############################################################################
#auxiliar functions
lmP=function(y,x,p.value=0.05){
sum.res<-summary(
stats::lm(y ~ as.factor(x))
)
pv<- stats::pf (sum.res$fstatistic[1],sum.res$fstatistic[2],
sum.res$fstatistic[3],,lower.tail=F)
if(pv<p.value) {
r<-sqrt(sum.res[["r.squared"]])
cat(paste("alternative hypothesis: true correlation is not equal to 0","\n",
"p-value: ",pv))
} else {
r<-0
cat(paste("there is no correlation at the confidence level  p-value<",p.value,"\n",
"p-value: ",pv))
}
return(r)
}
cramersVP=function(y,x,p.value,simulate.p.value = TRUE){
pv<-chisq.test(y,x,simulate.p.value=simulate.p.value)$p.value
if(pv<p.value) {
r<-lsr::cramersV(y,x, simulate.p.value=simulate.p.value)
cat(paste("alternative hypothesis: true correlation is not equal to 0","\n",
"p-value: ",pv))
} else {
r<-0
cat(paste("there is no correlation at the confidence level  p-value<",p.value,"\n",
"p-value: ",pv))
}
return(r)
}
corPerP=function(y,x,p.value,use){
res<- stats::cor.test(y,x,use,method="pearson",alternative = "two.sided")
pv<-res[["p.value"]]
if(pv<p.value) {
r<-res[["estimate"]]
cat(paste("alternative hypothesis: true correlation is not equal to 0","\n",
"p-value: ",pv))
} else {
r<-0
cat(paste("there is no correlation at the confidence level  p-value<",p.value,"\n",
"p-value: ",pv))
}
return(r)
}
##############################################################################
cor_fun <- function(df,pos_1, pos_2,p.value){
# both are numeric
if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
class(df[[pos_2]]) %in% c("integer", "numeric")){
r <- try(corPerP(df[[pos_1]]
, df[[pos_2]]
, p.value = p.value
, use = "pairwise.complete.obs")
)
}
# one is numeric and other is a factor/character
if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
class(df[[pos_2]]) %in% c("factor", "character")){
r <- try(
lmP(df[[pos_1]],df[[pos_2]],p.value = p.value)
)
}
if(class(df[[pos_2]]) %in% c("integer", "numeric") &&
class(df[[pos_1]]) %in% c("factor", "character")){
r <- try(
lmP(df[[pos_2]],df[[pos_1]],p.value = p.value)
)
}
# both are factor/character
if(class(df[[pos_1]]) %in% c("factor", "character") &&
class(df[[pos_2]]) %in% c("factor", "character")){
r <- try(cramersVP(df[[pos_1]], df[[pos_2]],p.value = p.value,
simulate.p.value = TRUE))
}
if((class(r) %in% "try-error")){
warnings(cat("some operations produces Nas values it will be replaced by 0.","\n",
pos_1, " FUN " ,pos_2,"\n"))
r<-0
}
return(r)
}
cor_fun <- Vectorize(cor_fun, vectorize.args=c("pos_1", "pos_2"))
#parallel corr matrix
cor_par <- function (df) {
`%dopar%` <- foreach::`%dopar%`
`%:%` <- foreach::`%:%`
dim<-NCOL(df)
corp <- foreach::foreach(i=1:dim,.export='cor_fun') %:%
foreach::foreach (j=1:dim) %dopar% {
corp = cor_fun(df,i,j,p.value=p.value)
}
matrix(unlist(corp), ncol=ncol(df))
}
# parallel corr matrix
if(isTRUE(parallel)){
doParallel::registerDoParallel(min(parallel::detectCores(),n.cores))
corrmat<-cor_par(df)
env <- foreach:::.foreachGlobals
rm(list=ls(name=env), pos=env)
} else {
# sequential corr matrix
corrmat <- outer(1:NCOL(df)
, 1:NCOL(df)
, function(x, y){cor_fun(df=df,x,y,p.value=p.value)})
}
rownames(corrmat) <- colnames(df)
colnames(corrmat) <- colnames(df)
return(corrmat)
}
a = corrP(iris,n.cores = 2)
cor_fun <- function(df,pos_1, pos_2,p.value){
# both are numeric
if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
class(df[[pos_2]]) %in% c("integer", "numeric")){
r <- try(corPerP(df[[pos_1]]
, df[[pos_2]]
, p.value = p.value
, use = "pairwise.complete.obs")
)
}
# one is numeric and other is a factor/character
if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
class(df[[pos_2]]) %in% c("factor", "character")){
r <- try(
lmP(df[[pos_1]],df[[pos_2]],p.value = p.value)
)
}
if(class(df[[pos_2]]) %in% c("integer", "numeric") &&
class(df[[pos_1]]) %in% c("factor", "character")){
r <- try(
lmP(df[[pos_2]],df[[pos_1]],p.value = p.value)
)
}
# both are factor/character
if(class(df[[pos_1]]) %in% c("factor", "character") &&
class(df[[pos_2]]) %in% c("factor", "character")){
r <- try(cramersVP(df[[pos_1]], df[[pos_2]],p.value = p.value,
simulate.p.value = TRUE))
}
if((class(r) %in% "try-error")){
warnings(cat("some operations produces Nas values it will be replaced by 0.","\n",
pos_1, " FUN " ,pos_2,"\n"))
r<-0
}
return(r)
}
cor_fun <- Vectorize(cor_fun, vectorize.args=c("pos_1", "pos_2"))
corrP = function(df,parallel=TRUE,n.cores=1,p.value=0.5,verbose=TRUE){
stopifnot(inherits(df, "data.frame"))
stopifnot(sapply(df, class) %in% c("integer"
, "numeric"
, "factor"
, "character"))
##############################################################################
#auxiliar functions
lmP=function(y,x,p.value=0.05){
sum.res<-summary(
stats::lm(y ~ as.factor(x))
)
pv<- stats::pf (sum.res$fstatistic[1],sum.res$fstatistic[2],
sum.res$fstatistic[3],,lower.tail=F)
if(pv<p.value) {
r<-sqrt(sum.res[["r.squared"]])
cat(paste("alternative hypothesis: true correlation is not equal to 0","\n",
"p-value: ",pv))
} else {
r<-0
cat(paste("there is no correlation at the confidence level  p-value<",p.value,"\n",
"p-value: ",pv))
}
return(r)
}
cramersVP=function(y,x,p.value,simulate.p.value = TRUE){
pv<-chisq.test(y,x,simulate.p.value=simulate.p.value)$p.value
if(pv<p.value) {
r<-lsr::cramersV(y,x, simulate.p.value=simulate.p.value)
cat(paste("alternative hypothesis: true correlation is not equal to 0","\n",
"p-value: ",pv))
} else {
r<-0
cat(paste("there is no correlation at the confidence level  p-value<",p.value,"\n",
"p-value: ",pv))
}
return(r)
}
corPerP=function(y,x,p.value,use){
res<- stats::cor.test(y,x,use,method="pearson",alternative = "two.sided")
pv<-res[["p.value"]]
if(pv<p.value) {
r<-res[["estimate"]]
cat(paste("alternative hypothesis: true correlation is not equal to 0","\n",
"p-value: ",pv))
} else {
r<-0
cat(paste("there is no correlation at the confidence level  p-value<",p.value,"\n",
"p-value: ",pv))
}
return(r)
}
#parallel corr matrix
cor_par <- function (df,p.value) {
`%dopar%` <- foreach::`%dopar%`
`%:%` <- foreach::`%:%`
dim<-NCOL(df)
corp <- foreach::foreach(i=1:dim,.export='cor_fun') %:%
foreach::foreach (j=1:dim) %dopar% {
corp = cor_fun(df,i,j,p.value=p.value)
}
matrix(unlist(corp), ncol=ncol(df))
}
##############################################################################
cor_fun <- function(df,pos_1, pos_2,p.value){
# both are numeric
if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
class(df[[pos_2]]) %in% c("integer", "numeric")){
r <- try(corPerP(df[[pos_1]]
, df[[pos_2]]
, p.value = p.value
, use = "pairwise.complete.obs")
)
}
# one is numeric and other is a factor/character
if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
class(df[[pos_2]]) %in% c("factor", "character")){
r <- try(
lmP(df[[pos_1]],df[[pos_2]],p.value = p.value)
)
}
if(class(df[[pos_2]]) %in% c("integer", "numeric") &&
class(df[[pos_1]]) %in% c("factor", "character")){
r <- try(
lmP(df[[pos_2]],df[[pos_1]],p.value = p.value)
)
}
# both are factor/character
if(class(df[[pos_1]]) %in% c("factor", "character") &&
class(df[[pos_2]]) %in% c("factor", "character")){
r <- try(cramersVP(df[[pos_1]], df[[pos_2]],p.value = p.value,
simulate.p.value = TRUE))
}
if((class(r) %in% "try-error")){
warnings(cat("some operations produces Nas values it will be replaced by 0.","\n",
pos_1, " FUN " ,pos_2,"\n"))
r<-0
}
return(r)
}
cor_fun <- Vectorize(cor_fun, vectorize.args=c("pos_1", "pos_2"))
# parallel corr matrix
if(isTRUE(parallel)){
doParallel::registerDoParallel(min(parallel::detectCores(),n.cores))
corrmat<-cor_par(df,p.value=p.value)
env <- foreach:::.foreachGlobals
rm(list=ls(name=env), pos=env)
} else {
# sequential corr matrix
corrmat <- outer(1:NCOL(df)
, 1:NCOL(df)
, function(x, y){cor_fun(df=df,x,y,p.value=p.value)})
}
rownames(corrmat) <- colnames(df)
colnames(corrmat) <- colnames(df)
return(corrmat)
}
a = corrP(iris,n.cores = 2)
a
a = corrP(df,n.cores = 2)
a
corrP = function(df,parallel=TRUE,n.cores=1,p.value=0.05,verbose=TRUE){
stopifnot(inherits(df, "data.frame"))
stopifnot(sapply(df, class) %in% c("integer"
, "numeric"
, "factor"
, "character"))
##############################################################################
#auxiliar functions
lmP=function(y,x,p.value=0.05){
sum.res<-summary(
stats::lm(y ~ as.factor(x))
)
pv<- stats::pf (sum.res$fstatistic[1],sum.res$fstatistic[2],
sum.res$fstatistic[3],,lower.tail=F)
if(pv<p.value) {
r<-sqrt(sum.res[["r.squared"]])
cat(paste("alternative hypothesis: true correlation is not equal to 0","\n",
"p-value: ",pv))
} else {
r<-0
cat(paste("there is no correlation at the confidence level  p-value<",p.value,"\n",
"p-value: ",pv))
}
return(r)
}
cramersVP=function(y,x,p.value,simulate.p.value = TRUE){
pv<-chisq.test(y,x,simulate.p.value=simulate.p.value)$p.value
if(pv<p.value) {
r<-lsr::cramersV(y,x, simulate.p.value=simulate.p.value)
cat(paste("alternative hypothesis: true correlation is not equal to 0","\n",
"p-value: ",pv))
} else {
r<-0
cat(paste("there is no correlation at the confidence level  p-value<",p.value,"\n",
"p-value: ",pv))
}
return(r)
}
corPerP=function(y,x,p.value,use){
res<- stats::cor.test(y,x,use,method="pearson",alternative = "two.sided")
pv<-res[["p.value"]]
if(pv<p.value) {
r<-res[["estimate"]]
cat(paste("alternative hypothesis: true correlation is not equal to 0","\n",
"p-value: ",pv))
} else {
r<-0
cat(paste("there is no correlation at the confidence level  p-value<",p.value,"\n",
"p-value: ",pv))
}
return(r)
}
#parallel corr matrix
cor_par <- function (df,p.value) {
`%dopar%` <- foreach::`%dopar%`
`%:%` <- foreach::`%:%`
dim<-NCOL(df)
corp <- foreach::foreach(i=1:dim,.export='cor_fun') %:%
foreach::foreach (j=1:dim) %dopar% {
corp = cor_fun(df,i,j,p.value=p.value)
}
matrix(unlist(corp), ncol=ncol(df))
}
##############################################################################
cor_fun <- function(df,pos_1, pos_2,p.value){
# both are numeric
if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
class(df[[pos_2]]) %in% c("integer", "numeric")){
r <- try(corPerP(df[[pos_1]]
, df[[pos_2]]
, p.value = p.value
, use = "pairwise.complete.obs")
)
}
# one is numeric and other is a factor/character
if(class(df[[pos_1]]) %in% c("integer", "numeric") &&
class(df[[pos_2]]) %in% c("factor", "character")){
r <- try(
lmP(df[[pos_1]],df[[pos_2]],p.value = p.value)
)
}
if(class(df[[pos_2]]) %in% c("integer", "numeric") &&
class(df[[pos_1]]) %in% c("factor", "character")){
r <- try(
lmP(df[[pos_2]],df[[pos_1]],p.value = p.value)
)
}
# both are factor/character
if(class(df[[pos_1]]) %in% c("factor", "character") &&
class(df[[pos_2]]) %in% c("factor", "character")){
r <- try(cramersVP(df[[pos_1]], df[[pos_2]],p.value = p.value,
simulate.p.value = TRUE))
}
if((class(r) %in% "try-error")){
warnings(cat("some operations produces Nas values it will be replaced by 0.","\n",
pos_1, " FUN " ,pos_2,"\n"))
r<-0
}
return(r)
}
cor_fun <- Vectorize(cor_fun, vectorize.args=c("pos_1", "pos_2"))
# parallel corr matrix
if(isTRUE(parallel)){
doParallel::registerDoParallel(min(parallel::detectCores(),n.cores))
corrmat<-cor_par(df,p.value=p.value)
env <- foreach:::.foreachGlobals
rm(list=ls(name=env), pos=env)
} else {
# sequential corr matrix
corrmat <- outer(1:NCOL(df)
, 1:NCOL(df)
, function(x, y){cor_fun(df=df,x,y,p.value=p.value)})
}
rownames(corrmat) <- colnames(df)
colnames(corrmat) <- colnames(df)
return(corrmat)
}
a = corrP(df,n.cores = 2)
a
a = corrP(df[1],n.cores = 2)
a
a = corrP(df[1:2],n.cores = 2)
a
