{
    "collab_server" : "",
    "contents" : "###############################################################################\n#\n# corrP\n# -- Compute correlations of columns of a dataframe of mixed types in parallel.\n#This Package is based on Srikanth KS (talegari) cor2 function.\n#\n###############################################################################\n#\n# author  : IDS siciliani (igor-siciliani)\n# license : GNU AGPLv3 (http://choosealicense.com/licenses/agpl-3.0/)\n# Based on Srikanth KS (talegari) cor2 function\n###############################################################################\n#' @title corrP\n#'\n#' @description Compute correlations of columns of a large dataframe of mixed types\n#' with parallel backend.\n#'   The dataframe is allowed to have columns of these four classes: integer,\n#'   numeric, factor and character. The character column is considered as\n#'   categorical variable. This Package is based on Srikanth KS (talegari) cor2 function.\n#'\n#' @details The correlation is computed as follows: \\itemize{\n#'\n#'   \\item integer/numeric pair: pearson correlation using `cor` function. The\n#'   valuelies between -1 and 1.\n#'\n#'   \\item integer/numeric - factor/categorical pair: correlation coefficient or\n#'   squared root of R^2 coefficient of linear regression of integer/numeric\n#'   variable over factor/categorical variable using `lm` function. The value\n#'   lies between 0 and 1.\n#'\n#'   \\item factor/categorical pair: cramersV value is\n#'   computed based on chisq test using `lsr::cramersV` function. The value lies\n#'   between 0 and 1.\n#'\n#'    \\item All statistical tests are controlled by the confidence internal of\n#'    p.value param. If the statistical tests do not obtain a significance lower\n#'    than p.value, by default the correlation between variables will be zero.\n#'\n#'    \\item If any errors occur during operations by default the correlation will be zero.\n#'\n#'\n#'   For a comprehensive implementation, use `polycor::hetcor`\n#'\n#' @param df input data frame\n#' @param parallel if is TRUE run the operations in parallel backend.\n#' @param n.cores The number of cores to use for parallel execution.\n#' @param p.value  p-value probability of obtaining the observed results of a test,\n#' assuming that the null hypothesis is correct. By default p.value=0.05.\n#'\n#' @author IDS siciliani (igor-siciliani)\n#'\n#' @keywords GNU AGPLv3 (http://choosealicense.com/licenses/agpl-3.0/)\n#'\n#' @examples\n#' iris_cor <- corrP(iris)\n#' corrplot::corrplot(iris_cor)\n#' corrgram::corrgram(iris_cor)\n#'\ncorrP = function(df,parallel=TRUE,n.cores=1,p.value=0.05,verbose=TRUE){\n\n  stopifnot(inherits(df, \"data.frame\"))\n  stopifnot(sapply(df, class) %in% c(\"integer\"\n                                     , \"numeric\"\n                                     , \"factor\"\n                                     , \"character\"))\n  ##############################################################################\n  #auxiliar functions\n  lmP=function(y,x,p.value=0.05){\n\n    sum.res<-summary(\n          stats::lm(y ~ as.factor(x))\n          )\n    pv<- stats::pf (sum.res$fstatistic[1],sum.res$fstatistic[2],\n                    sum.res$fstatistic[3],,lower.tail=F)\n\n    if(pv<p.value) {\n      r<-sqrt(sum.res[[\"r.squared\"]])\n      cat(paste(\"alternative hypothesis: true correlation is not equal to 0\",\"\\n\",\n                \"p-value: \",pv))\n    } else {\n      r<-0\n      cat(paste(\"there is no correlation at the confidence level  p-value<\",p.value,\"\\n\",\n                \"p-value: \",pv))\n    }\n\n    return(r)\n\n  }\n\n  cramersVP=function(y,x,p.value,simulate.p.value = TRUE){\n    pv<-chisq.test(y,x,simulate.p.value=simulate.p.value)$p.value\n\n    if(pv<p.value) {\n      r<-lsr::cramersV(y,x, simulate.p.value=simulate.p.value)\n      cat(paste(\"alternative hypothesis: true correlation is not equal to 0\",\"\\n\",\n                \"p-value: \",pv))\n    } else {\n      r<-0\n      cat(paste(\"there is no correlation at the confidence level  p-value<\",p.value,\"\\n\",\n                \"p-value: \",pv))\n    }\n\n    return(r)\n\n  }\n\n  corPerP=function(y,x,p.value,use){\n\n    res<- stats::cor.test(y,x,use,method=\"pearson\",alternative = \"two.sided\")\n    pv<-res[[\"p.value\"]]\n\n    if(pv<p.value) {\n      r<-res[[\"estimate\"]]\n      cat(paste(\"alternative hypothesis: true correlation is not equal to 0\",\"\\n\",\n                \"p-value: \",pv))\n    } else {\n      r<-0\n      cat(paste(\"there is no correlation at the confidence level  p-value<\",p.value,\"\\n\",\n                \"p-value: \",pv))\n    }\n\n    return(r)\n\n  }\n\n  #parallel corr matrix\n  cor_par <- function (df,p.value) {\n    `%dopar%` <- foreach::`%dopar%`\n    `%:%` <- foreach::`%:%`\n    dim<-NCOL(df)\n    corp <- foreach::foreach(i=1:dim,.export='cor_fun') %:%\n      foreach::foreach (j=1:dim) %dopar% {\n        corp = cor_fun(df,i,j,p.value=p.value)\n      }\n    matrix(unlist(corp), ncol=ncol(df))\n  }\n\n  ##############################################################################\n\n  cor_fun <- function(df,pos_1, pos_2,p.value){\n\n    # both are numeric\n\n    if(class(df[[pos_1]]) %in% c(\"integer\", \"numeric\") &&\n       class(df[[pos_2]]) %in% c(\"integer\", \"numeric\")){\n      r <- try(corPerP(df[[pos_1]]\n                      , df[[pos_2]]\n                      , p.value = p.value\n                      , use = \"pairwise.complete.obs\")\n           )\n    }\n\n    # one is numeric and other is a factor/character\n\n    if(class(df[[pos_1]]) %in% c(\"integer\", \"numeric\") &&\n       class(df[[pos_2]]) %in% c(\"factor\", \"character\")){\n      r <- try(\n        lmP(df[[pos_1]],df[[pos_2]],p.value = p.value)\n      )\n    }\n\n    if(class(df[[pos_2]]) %in% c(\"integer\", \"numeric\") &&\n       class(df[[pos_1]]) %in% c(\"factor\", \"character\")){\n      r <- try(\n        lmP(df[[pos_2]],df[[pos_1]],p.value = p.value)\n      )\n    }\n\n    # both are factor/character\n\n    if(class(df[[pos_1]]) %in% c(\"factor\", \"character\") &&\n       class(df[[pos_2]]) %in% c(\"factor\", \"character\")){\n       r <- try(cramersVP(df[[pos_1]], df[[pos_2]],p.value = p.value,\n                          simulate.p.value = TRUE))\n\n\n    }\n\n\n    if((class(r) %in% \"try-error\")){\n      warnings(cat(\"some operations produces Nas values it will be replaced by 0.\",\"\\n\",\n                     pos_1, \" FUN \" ,pos_2,\"\\n\"))\n      r<-0\n    }\n    return(r)\n  }\n\ncor_fun <- Vectorize(cor_fun, vectorize.args=c(\"pos_1\", \"pos_2\"))\n\n\n # parallel corr matrix\n  if(isTRUE(parallel)){\n\n    doParallel::registerDoParallel(min(parallel::detectCores(),n.cores))\n    corrmat<-cor_par(df,p.value=p.value)\n    env <- foreach:::.foreachGlobals\n    rm(list=ls(name=env), pos=env)\n\n  } else {\n  # sequential corr matrix\n  corrmat <- outer(1:NCOL(df)\n                   , 1:NCOL(df)\n                   , function(x, y){cor_fun(df=df,x,y,p.value=p.value)})\n  }\n  rownames(corrmat) <- colnames(df)\n  colnames(corrmat) <- colnames(df)\n\n  return(corrmat)\n}\n",
    "created" : 1580497622900.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2453086244",
    "id" : "9039D622",
    "lastKnownWriteTime" : 1580582233,
    "last_content_update" : 1580582233262,
    "path" : "D:/mineral/corrP/coorP/R/corrP.R",
    "project_path" : "R/corrP.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}